# 代码大全

## 软件构建

+ 定义问题
+ 需求分析
+ 规划构建
+ 软件架构/高层设计
+ 详细设计
+ 编码与调试
+ 单元测试
+ 集成测试
+ 集成
+ 系统测试
+ 保障维护

## 一些构建活动中的具体任务

+ 验证有关的基础工作是否已经完成，因此构建活动可以顺利的进行下去
+ 确定如何测试所写的代码
+ 设计并编写类和子程序
+ 创建并命名变量和具名常量（named constant）
+ 选择控制结构，组织语句块
+ <font color=red>对你的代码进行单元测试和集成测试，并排除其中的错误</font>
+ 评审开发团队其他成员的底层设计与代码，并让他们评审你的工作
+ 润饰代码，仔细进行代码的格式化和注释
+ 经单独开发的多个软件组件集成为一体
+ 调整代码，让它更快，更省资源。

## Key Points 要点

+ 软件构建是软件开发的核心活动；构建活动是每个项目中唯一一项不可缺少的工作
+ 软件构建的主要活动包括：详细设计、编码、调试、集成、开发者测试（developer testing）包括单元测试与集成测试
+ 构建也常称作编码和编程
+ 构建活动的质量对软件的质量有着实质性的影响
+ 对如何构建的理解，决定了作为程序员的优秀程度

## 第二章 用隐喻来充分理解软件开发

+ 隐喻的重要性：通过将你不太理解的东西和一些你较为理解、且十分类似的东西作比较，你可以对这些不太理解的东西产生更深刻的理解，该方法称为建模（modeling）。模型的威力在于其生动性，能够让你把握整个概念。他能够隐隐的暗示各种属性properties、关系relationships以及需要补充查证的部分（additional areas of inquiry）。模型有其适用范围，即使在理论上被推翻。（牛顿力学与广义相对论）

+ 明确的算法与启发性的算法

+ 代码的可读性
+ 系统生长，增量的incremental、迭代的iterative、自适应的adaptive、演进的evolutionarty。以增量方式进行设计、编译和测试，都是目前已知的最强有力的软件开发概念

+ 进行增量式开发时，我们先做出软件系统的一个尽可能简单、但能运行的版本。他不必接受真实的输入，也不必要对数据进行真正的处理，更不用产生真实的输出--它仅需要构成一个足够强壮的骨架，支撑起未来将要开发的真实系统。对于你标志出每一项基本功能，可能仅需要调用虚假的类（dummy classes）。这个最基本的起点，就像牡蛎开始孕育珍珠的那颗细小沙粒。在骨架形成之后，你要一点点地在其上附着肌肉和皮肤：把每个虚假的类替换成真正的类：不再假装接受输入，而是把接受真实输入的代码替换进去；不再假装产生输出，而是把真实输出的代码替换进去。你一次增加一小部分代码，直到得到一个完全可以工作的系统。

+ 更为复杂的结构需要更加仔细的规划

+ 自己编写那些能够买得到的现成的代码通常是没有意义的

+ 软件的构建和建筑有很多的共同性，有时只需要用灵活的、轻量级的方法，但有时你就必须得用严格的、重量级的开发方法，以达到所需的安全性目的或其他的什么目标。最后建筑这一隐喻让人们对超大型的软件项目的认识更加深刻。超大型的结构一旦出了问题，后果是十分严重的。因此有必要对这样的结构进行超出常规的规划和建设。同理，对于超大型的软件项目，就需要比一般规模的项目有更高级别的规划设计。如果需要创造在经济规模上可以匹敌帝国大厦的庞大的软件项目，那么与之相当水准的技术与管理控制也是必需的。

+ 很多软件开发术语都是从建筑这一隐喻中衍生出来的：软件架构（architecture）、支撑性测试代码（脚手架，scaffolding）、构建construction、基础类foundation classes以及分离代码tearing code apart。

+ 隐喻是启示而不是算法。因此它们往往有一点随意sloopy

+ 通过把软件开发中的实践比作是智慧工具箱中的工具，我们可以发现，每位程序员都有很多工具，但并不存在任何一个能适用于所有工作的工具，因地制宜地选择正确工具是成为能够有效编程的关键
+ 不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合

## 第三章 三思而后行：前期准备(Measure Twice, Cut Once: Upstream Prerequisites))

### 3.1 前期准备的重要性
+ 软件开发中最常见的项目风险是糟糕的需求分析和糟糕的项目计划，因此准备工作就倾向于集中改进需求分析和项目规划
+ 当开发人员不知道如何进行这些前期工作的时候，建议做更对的前期工作就完全没有用，如果不能首先把这项工作做好，那做再多也是没有意义的。
+ 管理者们应该要明白，软件开发不仅仅是写代码
+ 关于开始构建之前要做的前期准备的绝对有力且简明的论据
  + 诉诸逻辑 Appeal to Logic
  + 诉诸类比 Appeal to Analogy 程序员是软件食物链的最后一环。架构师吃掉需求，设计师吃掉架构，而程序员消化设计
  + 诉诸数据 Appeal to Data bug越早发现，修复成本越低
  + 老板就绪测试 Boss-Readiness Test 
### 3.2 辨明你说从事的软件的类型
+ 需求稳定是确保超高等级的可靠性的必备条件之一
+ 使用迭代方法往往能够减少前期准备不足造成的负面影响，但它不能完全消除此影响
### 3.3 问题定义的先决条件
+ 问题定义只定义了问题是什么，而不涉及任何可能的解决方案。问题的定义在具体的需求分析工作之前，而需求分析是对所定义的问题的深入调查。
+ 问题定义应该用客户的语言来书写，而且应该从客户的角度来描述问题。
+ 如果没有一个良好的问题定义，你努力解决的可能是一个错误的问题，未能定义问题的处罚是，你浪费了大量的时间去解决错误的问题。这是双重处罚，因为你也没有解决正确的问题。
### 需求的先决条件
+ 需求详细描述软件系统应该做什么，这是达成解决方案的第一步。
+ 稳定的需求是软件开发的圣杯，需求文档不改变是不可能的。开发过程能够帮助客户更好的理解自己的需求，这是需求变更的主要来源。平均水平的项目在开发过程中，需求会有25%的变更。
+ 确保每个人都知道需求变更的代价。客户、开发、产品
  + 建立一套变更控制程序
  + 使用能适应变更的开发方法：演进原型
  + 放弃这个项目
  + 注意项目的商业案例，有些需求作为功能特色来看是不错的想法，但是当你评估增加的商业价值时就会觉得它是一个糟糕了的主意。
+ 核对表：需求
  + 针对功能需求
    + 是否详细定义了系统的全部输入，包括其来源、精度、取值范围、出现频率等？
    + 是否详细定义了系统的全部输出，包括目的地、精度、取值范围、出现频率、格式等？
    + 是否详细定义了所有的输出格式（web、报表等等）？
    + 是否详细定义了所有硬件及软件的外部接口？
    + 是否详细定义了全部的外部通信接口，包括握手协议、纠错协议、通信协议等？
    + 是否列出了用户想要做的全部事情？
    + 是否详细定义了每个任务所用的数据，以及每个任务得到的数据？
  + 针对非功能需求（质量需求）



