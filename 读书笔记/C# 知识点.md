# 面试知识点

1. **什么是装箱和拆箱**
   + 装箱：将值类型转化成引用类型（object），可以隐式装箱
   + 拆箱：将引用类型转换成值类型，不可以隐式拆箱
   + 主要用于类型转换，会影响性能
2. **什么是函数重载（overload）与函数重写（override）**
   + 函数重载：
     + a. 方法名相同
     + b. 方法参数类型不同或者参数个数不同
     + c. 在同一个类中
     + 注： 返回值类型不同的方法不能构成重载
   + 函数重写：
     + 子类重写父类的方法
     + 只有基类成员声明为virtual或abstract时，才能被派生类重
     + 如果子类想改变虚方法的实现行为，则必须使用override关键字
3. ***什么是多态，如何实现多态***
   + 多态：不同的对象对同一消息作出不同的响应就是多态。
   + 真正的多态是通过重写实现的
   + 基类中的方法通过virtual标记为虚拟方法，再在派生类中用override关键字对虚拟方法进行修饰进行重写，进而实现多态，子类的子类依然可以重写基类的方法。如果想要终止重写，用sealed关键字修饰，包含虚函数的类可以实例化，包含抽象方法的类不能被实例化。

4. 虚函数（Virtual），抽象函数（abstract）和接口的区别
   1. virtual：允许被重写，但不强制要求。声明时提供其自身实现；
   2. abstract：强制要求其继承者重写。声明时不提供其自身的实现，抽象类不能被实例化；
   3. interface：接口就是协议，其声明的成员（属性，方法，事件和索引器）必须由其继承的类实现。接口不能直接被实例化。
   4. 虚方法与抽象方法的区别在于，虚方法提供自身的实现，并且不强制要求子类重写；而抽象方法不提供自身的实现，并且强制子类重写。
   5. 抽象类与接口很相似，但是思路不一样。接口是公开类的成员，而抽象类则是抽象类成员以要求子类继承并实现。
5. 结构体与类的区别
   1. 结构是值类型，存储在栈内存中，类是引用类型，存储在堆内存中
   2. 结构不支持继承
   3. 较小的数据类型可以使用结构提高性能
   4. 
6. ***什么是值类型和引用类型***
   1. 值类型在栈内存中，引用类型在堆内存，栈内存仅保存数据存放的地址
   2. 值类型存取快，引用类型存取慢
   3. 值类型表示实际数据，引用类型为指向数据内存的指针或引用
   4. 值类型继承自system.ValueType，引用类型继承自system.Object
   5. 栈的内存分配是自动释放，而堆内存在.NET中有GC来释放
   6. 值赋值是数据直接复制一份，引用赋值是改变引用的指向，多个引用都指向同一块内存，一个修改，全都变
7. 几种常见的设计模式
8. 如何将字符串转成整数
9.  什么是栈内存和堆内存其与数据结构中的堆与栈有什么关系
10. 什么是重构
    + 重构是对软件内部结构的一种调转，目的是不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。那么如果保证不改变软件可观察行为呢？就需要写测试用例，保证测试用例能跑通的情况下进行重新构造代码才是重构的第一步，没有测试用例的重构就是耍流氓。

## 知识点

+ string是引用类型，分配在堆内存中，赋值会得到对内存中同一字符串的两个引用。但是字符串不可改变，修改其中一个字符串，就会创建一个全新的string对象，而另一个字符串不发生变化
+ 在字符串字面量前加字符@，则所有字符都不会被解释称转义字符和python中的‘r’效果相同
+ 字符串格式化：<font color=red>**$"s1 is {var}", var会替换成变量值 C#6** </font>
+ C# 中if子句中的表达式必须是布尔类型，不能是整数
+ 善用枚举
+ 命名空间 CompanyName.ProjectName.SystemSection
+ 指定命名空间的别名 using alias = NamespaceName
+ 添加xml注释 /summary>returns/> param/>/summary>
+ <font color=red>***C# 预处理指令***</font>
  + #defind 与 #undef
    + #define 本身没什么用，但与其他预处理器指令（特别是#if）结合使用时，它的功能就非常强大了。预处理指令不用分号结束
  + #if、#elif、#else、#endif
    + 当编译器遇到#if指令后，将先检查相关的符号是否存在，如果符号存在就编译#if子句中的代码。否则，编译器会忽略所有#endif之前的代码，将#define指令注释掉，所有的调试代码会奇迹般地消失，可执行程序也会变小。称之为条件编译
    + 可以有逻辑运算
  + #warning与#error
    + #if DEBUG && RELEASE #error #endif
  + #region 和 #endregion
    + 上述指令将一段代码视为由给定名称的一个块，其真正的优点是它们可以被某些编译器识别，使代码更好的布局
  + #line 与 #line default
  + #pragma 可以抑制或还原指定的编译警告
+ ***C# 编程准则***
  + 变量名（标识符）必须以字母或下划线开头
  + 不能以C#关键字用作标识符（29个）
  + 为什么不将C#新版本添加的一些新关键字列在保留字列表？解决方案是把这些关键字定义为上下文关键字，以改进语法。
  + 命名约定
    + Pascal驼峰命名法 首字母大写
    + camel命名法 首字母不大写 三种情况下使用该命名规则
      + <font color=red>**类型中所有私有成员字段的名称**</font> 
        + private int subscriberId;
        + 但是注意成员字段的前缀名常常用一条下划线开头
        + private int _subscriberId;
      + <font color=red>**传递给方法的所有参数的名称**</font>
        + public void RecordSale(string salesmanName,int quantity);
      + <font color=red>**用于区分同名的两个对象--比较常见的是属性封装字段**</font>

        + ```csharp
            private string employeeName;
            public string EmployeeName{
               get{return employeeName;}
               set{employeeName = value;}//编译器假定它带一个参数，其类型也与属性相同，并表示为value
            }
            ```
         + 如果这么做，则私有成员总是使用camel大小写形式，而公有的或受保护的成员总是使用Pascal大小写形式
  + 名称风格应保持一致 
    + 例如ShowConfirmationDialog 与 ShowDialogWarning风格不匹配，应该使用ShowWarningDialog
  + 名称空间的命名 
    + Microsoft 建议使用如下的名称空间：CompanyName.TechnologyName
  + 名称与关键字
  + 属性和方法的使用 类中出现混乱的一个方向是某个特定数量是用属性还是方法来表示。一般来说，如果该对象的外观像变量，就应该使用属性来表示它
    + 客户端代码应能读取它的值。最好不要使用只写属性，例如应使用SetPassword()方法，而不是Password只写属性。
    + 将不变的设为属性，变化的设为方法，如GetSpeed()，Weight
  + 字段的使用，字段的使用非常简单，字段应总是私有的，但在某些情况下，也可以把常量或只读字段设置成公有。因为如果将字段设置成公有，就不利于在以后扩展或修改类。最好将字段声明称私有的，然后通过属性来访问字段（get、set方法）
  + 自动实现的属性
    + 如果属性的set和get访问器中没有任何逻辑，就可以使用自动实现的属性，这种属性会自动实现后备成员变量。例如：public int Age {get;set;} 自动实现的属性可以使用属性初始化器来初始化：public int Age {get;set;} = 42;
    + 属性的访问修饰符 必须有一个具备属性的访问级别 public int Age {get；private set;}
  + 方法
    + 方法的声明 [modifiers] return_type MethodName([parameters]){//Method body}
    + 表达式体方法 public bool IsSquare(Rectangle rect) => rect.Height == rect.Width;
    + 调用方法 静态方法通过类名调用，非静态方法公有方法通过实例化对象调用
    + 方法重载 方法的几个版本有不同的签名（即，方法名相同，但参数的个数或数据类型不同，返回值不同不算，参数名称不同不算）

+ 强制转换与as、is运算符
  + 强制转换不成功会抛出InvalidCastException
  + as 运算符返回对象的引用，不抛异常，但如果对象不是所需要的类型，这个运算符就返回null
  + is 运算符 根据条件是否满足，对象是否使用指定的类型，返回true或false，验证条件是true，可以进行类型转换